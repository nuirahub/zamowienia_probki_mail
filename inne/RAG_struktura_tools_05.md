To jest kluczowy moment architektury. Najczęstszym błędem jest tworzenie osobnego narzędzia dla każdej tabeli (Tool dla Klientów, Tool dla Zamówień, Tool dla Produktów). Dla modeli 8B (Qwen, Llama 3) to "śmierć przez złożoność" – model zgubi się przy próbie łączenia (joinowania) danych między narzędziami.Moja rekomendacja: Nie dziel narzędzi według tematów (Klient, Produkt), ale według STRUKTURY DANYCH.Oto jak powinnaś zdefiniować narzędzia i przygotować dane w pgvector.1. Jak zdefiniować Tools? (Zasada 2 Narzędzi)Zamiast 4 narzędzi, zdefiniuj tylko dwa główne. To drastycznie uprości pracę Routera.Narzędzie 1: sql_database (Structured Data)To narzędzie ma dostęp do wszystkich tabel relacyjnych: Klienci, Produkty, Zamówienia.Dlaczego razem? Pytanie o "kawę instant" wymaga zrobienia JOIN-a między tabelami Produktów, Zamówień i Klientów. SQL robi to idealnie. Model 8B świetnie pisze proste zapytania SQL z JOIN-ami.Kiedy używać? Zawsze, gdy pytanie wymaga precyzyjnych list, liczb, dat, danych kontaktowych, historii zakupów.Narzędzie 2: notes_knowledge_base (Unstructured Data / pgvector)To narzędzie ma dostęp tylko do Notatek.Dlaczego osobno? Tutaj szukamy "znaczenia", "kontekstu", "problemów". To nie są ścisłe wiersze w tabeli, tylko tekst.Kiedy używać? Podsumowania, szukanie sentymentu, "o czym rozmawialiśmy".2. Analiza Twoich przykładowych pytańZobaczmy, jak Router powinien skierować Twoje pytania w tym układzie:Pytanie A: "Podaj osoby kontaktowe dla klientów, którzy w ostatnim miesiącu zamówili produkty: kawa instant?"Narzędzie: sql_databaseDlaczego: To czyste dane strukturalne. Model wygeneruje SQL:SQLSELECT c.contact_name, c.phone
FROM clients c
JOIN orders o ON c.id = o.client_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE p.name ILIKE '%kawa instant%'
  AND o.order_date >= NOW() - INTERVAL '1 month';
Gdybyś użyła wektorów do tego pytania, dostałabyś halucynacje lub niekompletne dane.Pytanie B: "Z jakim klientem widziałem się w zeszłym tygodniu?"Narzędzie: To zależy od tego, jak zapisujesz spotkania.Wariant 1 (Spotkanie to tylko notatka): notes_knowledge_base z filtrem metadanych (Data).Wariant 2 (Spotkanie to rekord w kalendarzu/CRM): sql_database.Rekomendacja: Zazwyczaj "odbycie spotkania" to fakt, więc SQL. Ale "o czym było spotkanie" to Vector.3. Jak zbudować dane wektorowe w PostgreSQL (pgvector)?To jest najważniejsza część techniczna. Aby pgvector był użyteczny w RAG sprzedażowym, nie możesz wrzucić samej treści notatki do wektora. Musisz zastosować strategię Hybrid Search (Wektor + Metadane).W bazie Postgres powinnaś mieć tabelę meeting_notes_embeddings o takiej strukturze:KolumnaTypOpis / Co tam wkładamy?idUUIDUnikalny ID kawałka tekstu (chunk).client_idINTKlucz obce do tabeli SQL Klienci. To jest Twój "most" między światami.contentTEXTTreść notatki (chunk), np. "Klient narzekał na opóźnienia w dostawie..."embeddingVECTORWektor wygenerowany z kolumny content.metadataJSONBKluczowe dla filtrowania! Np. {"date": "2023-10-27", "author": "Jan Kowalski", "type": "meeting"}Dlaczego taka struktura?Wyobraź sobie pytanie: "Co o nowym produkcie mówił klient X?"Model LLM najpierw wyciąga z pytania nazwę klienta "X".Router wie, że musi użyć notes_knowledge_base.Zamiast szukać w całej bazie wektorowej (co dałoby opinie innych klientów), system robi:SQLSELECT content
FROM meeting_notes_embeddings
WHERE client_id = 123  -- Filtrowanie twarde (SQL)
ORDER BY embedding <=> [wektor_zapytania] LIMIT 5; -- Szukanie semantyczne (Vector)
To tzw. Pre-filtering. W LangChain obsługuje się to przez SelfQueryRetriever lub przekazując parametry filtrujące do vector store.4. Schemat definicji Toola (Pydantic) dla NotatekZdefiniuj VectorTool tak, aby model wiedział, że może filtrować po kliencie i dacie.Pythonclass VectorSearchInput(BaseModel):
    query: str = Field(description="Semantyczne pytanie, np. 'opinie o produkcie', 'ustalenia ze spotkania'")
    client_name: Optional[str] = Field(description="Nazwa klienta, jeśli pytanie dotyczy konkretnej firmy. Używane do filtrowania.")
    date_range: Optional[str] = Field(description="Zakres dat, np. 'last month', '2023 year'.")

# Dzięki temu model Qwen3 wie, że może poprosić o:
# { "query": "opinie o kawie", "client_name": "CafePol", "date_range": null }
# A Ty w kodzie zamieniasz "CafePol" na client_id i robisz precyzyjne wyszukiwanie.
Podsumowanie strategiiStruktura Tabel SQL: Klienci, Produkty, Zamówienia (powiązane kluczami obcymi).Struktura Vector Store: Tabela z embeddingami notatek, która obowiązkowo ma kolumnę client_id oraz datę w metadanych (JSONB).Definicja Narzędzi:sql_tool: "Use for retrieving structured data like orders, product lists, client contact details, prices, and linking these entities."vector_tool: "Use for searching within meeting notes, emails, and conversation history. Can be filtered by client name and date."
